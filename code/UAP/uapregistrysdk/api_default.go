/*
Service API

API for managing services

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package uapregistrysdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type DefaultAPI interface {

	/*
		RoutesGet Get all routes

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiRoutesGetRequest
	*/
	RoutesGet(ctx context.Context) ApiRoutesGetRequest

	// RoutesGetExecute executes the request
	//  @return []Route
	RoutesGetExecute(r ApiRoutesGetRequest) ([]Route, *http.Response, error)

	/*
		RoutesPost Register a new route

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiRoutesPostRequest
	*/
	RoutesPost(ctx context.Context) ApiRoutesPostRequest

	// RoutesPostExecute executes the request
	//  @return Route
	RoutesPostExecute(r ApiRoutesPostRequest) (*Route, *http.Response, error)

	/*
		RoutesRouteNameDelete Delete a route

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param routeName
		@return ApiRoutesRouteNameDeleteRequest
	*/
	RoutesRouteNameDelete(ctx context.Context, routeName string) ApiRoutesRouteNameDeleteRequest

	// RoutesRouteNameDeleteExecute executes the request
	RoutesRouteNameDeleteExecute(r ApiRoutesRouteNameDeleteRequest) (*http.Response, error)

	/*
		RoutesRouteNameGet Get a route by name

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param routeName
		@return ApiRoutesRouteNameGetRequest
	*/
	RoutesRouteNameGet(ctx context.Context, routeName string) ApiRoutesRouteNameGetRequest

	// RoutesRouteNameGetExecute executes the request
	//  @return Route
	RoutesRouteNameGetExecute(r ApiRoutesRouteNameGetRequest) (*Route, *http.Response, error)

	/*
		RoutesRouteNamePut Update a route

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param routeName
		@return ApiRoutesRouteNamePutRequest
	*/
	RoutesRouteNamePut(ctx context.Context, routeName string) ApiRoutesRouteNamePutRequest

	// RoutesRouteNamePutExecute executes the request
	//  @return Route
	RoutesRouteNamePutExecute(r ApiRoutesRouteNamePutRequest) (*Route, *http.Response, error)

	/*
		ServicesGet Get all services

		Retrieve a list of all services

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiServicesGetRequest
	*/
	ServicesGet(ctx context.Context) ApiServicesGetRequest

	// ServicesGetExecute executes the request
	//  @return []Service
	ServicesGetExecute(r ApiServicesGetRequest) ([]Service, *http.Response, error)

	/*
		ServicesIdDelete Delete a service

		Delete an existing service

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id ID of the service to delete
		@return ApiServicesIdDeleteRequest
	*/
	ServicesIdDelete(ctx context.Context, id string) ApiServicesIdDeleteRequest

	// ServicesIdDeleteExecute executes the request
	ServicesIdDeleteExecute(r ApiServicesIdDeleteRequest) (*http.Response, error)

	/*
		ServicesIdPatch Update a service

		Update an existing service

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id ID of the service to update
		@return ApiServicesIdPatchRequest
	*/
	ServicesIdPatch(ctx context.Context, id string) ApiServicesIdPatchRequest

	// ServicesIdPatchExecute executes the request
	//  @return Service
	ServicesIdPatchExecute(r ApiServicesIdPatchRequest) (*Service, *http.Response, error)

	/*
		ServicesIdRenewalPut Renewal a service

		Renewal a service

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id ID of the service to renewal
		@return ApiServicesIdRenewalPutRequest
	*/
	ServicesIdRenewalPut(ctx context.Context, id string) ApiServicesIdRenewalPutRequest

	// ServicesIdRenewalPutExecute executes the request
	ServicesIdRenewalPutExecute(r ApiServicesIdRenewalPutRequest) (*http.Response, error)

	/*
		ServicesPost Create a new service

		Create a new service

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiServicesPostRequest
	*/
	ServicesPost(ctx context.Context) ApiServicesPostRequest

	// ServicesPostExecute executes the request
	//  @return Service
	ServicesPostExecute(r ApiServicesPostRequest) (*Service, *http.Response, error)

	/*
		ServicesServiceNameGet Get service by name

		Retrieve services by serviceName

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param serviceName Name of the service to retrieve
		@return ApiServicesServiceNameGetRequest
	*/
	ServicesServiceNameGet(ctx context.Context, serviceName string) ApiServicesServiceNameGetRequest

	// ServicesServiceNameGetExecute executes the request
	//  @return []Service
	ServicesServiceNameGetExecute(r ApiServicesServiceNameGetRequest) ([]Service, *http.Response, error)
}

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiRoutesGetRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
	wait       *string
	index      *string
}

// wait seconds
func (r ApiRoutesGetRequest) Wait(wait string) ApiRoutesGetRequest {
	r.wait = &wait
	return r
}

// index
func (r ApiRoutesGetRequest) Index(index string) ApiRoutesGetRequest {
	r.index = &index
	return r
}

func (r ApiRoutesGetRequest) Execute() ([]Route, *http.Response, error) {
	return r.ApiService.RoutesGetExecute(r)
}

/*
RoutesGet Get all routes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRoutesGetRequest
*/
func (a *DefaultAPIService) RoutesGet(ctx context.Context) ApiRoutesGetRequest {
	return ApiRoutesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Route
func (a *DefaultAPIService) RoutesGetExecute(r ApiRoutesGetRequest) ([]Route, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Route
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RoutesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.wait != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait", r.wait, "form", "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoutesPostRequest struct {
	ctx                context.Context
	ApiService         DefaultAPI
	createRouteRequest *CreateRouteRequest
}

func (r ApiRoutesPostRequest) CreateRouteRequest(createRouteRequest CreateRouteRequest) ApiRoutesPostRequest {
	r.createRouteRequest = &createRouteRequest
	return r
}

func (r ApiRoutesPostRequest) Execute() (*Route, *http.Response, error) {
	return r.ApiService.RoutesPostExecute(r)
}

/*
RoutesPost Register a new route

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRoutesPostRequest
*/
func (a *DefaultAPIService) RoutesPost(ctx context.Context) ApiRoutesPostRequest {
	return ApiRoutesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Route
func (a *DefaultAPIService) RoutesPostExecute(r ApiRoutesPostRequest) (*Route, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Route
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RoutesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createRouteRequest == nil {
		return localVarReturnValue, nil, reportError("createRouteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createRouteRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoutesRouteNameDeleteRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
	routeName  string
}

func (r ApiRoutesRouteNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.RoutesRouteNameDeleteExecute(r)
}

/*
RoutesRouteNameDelete Delete a route

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param routeName
	@return ApiRoutesRouteNameDeleteRequest
*/
func (a *DefaultAPIService) RoutesRouteNameDelete(ctx context.Context, routeName string) ApiRoutesRouteNameDeleteRequest {
	return ApiRoutesRouteNameDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		routeName:  routeName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RoutesRouteNameDeleteExecute(r ApiRoutesRouteNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RoutesRouteNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routes/{routeName}"
	localVarPath = strings.Replace(localVarPath, "{"+"routeName"+"}", url.PathEscape(parameterValueToString(r.routeName, "routeName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoutesRouteNameGetRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
	routeName  string
	wait       *string
	index      *string
}

// wait seconds
func (r ApiRoutesRouteNameGetRequest) Wait(wait string) ApiRoutesRouteNameGetRequest {
	r.wait = &wait
	return r
}

// index
func (r ApiRoutesRouteNameGetRequest) Index(index string) ApiRoutesRouteNameGetRequest {
	r.index = &index
	return r
}

func (r ApiRoutesRouteNameGetRequest) Execute() (*Route, *http.Response, error) {
	return r.ApiService.RoutesRouteNameGetExecute(r)
}

/*
RoutesRouteNameGet Get a route by name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param routeName
	@return ApiRoutesRouteNameGetRequest
*/
func (a *DefaultAPIService) RoutesRouteNameGet(ctx context.Context, routeName string) ApiRoutesRouteNameGetRequest {
	return ApiRoutesRouteNameGetRequest{
		ApiService: a,
		ctx:        ctx,
		routeName:  routeName,
	}
}

// Execute executes the request
//
//	@return Route
func (a *DefaultAPIService) RoutesRouteNameGetExecute(r ApiRoutesRouteNameGetRequest) (*Route, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Route
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RoutesRouteNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routes/{routeName}"
	localVarPath = strings.Replace(localVarPath, "{"+"routeName"+"}", url.PathEscape(parameterValueToString(r.routeName, "routeName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.wait != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait", r.wait, "form", "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoutesRouteNamePutRequest struct {
	ctx                context.Context
	ApiService         DefaultAPI
	routeName          string
	updateRouteRequest *UpdateRouteRequest
}

func (r ApiRoutesRouteNamePutRequest) UpdateRouteRequest(updateRouteRequest UpdateRouteRequest) ApiRoutesRouteNamePutRequest {
	r.updateRouteRequest = &updateRouteRequest
	return r
}

func (r ApiRoutesRouteNamePutRequest) Execute() (*Route, *http.Response, error) {
	return r.ApiService.RoutesRouteNamePutExecute(r)
}

/*
RoutesRouteNamePut Update a route

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param routeName
	@return ApiRoutesRouteNamePutRequest
*/
func (a *DefaultAPIService) RoutesRouteNamePut(ctx context.Context, routeName string) ApiRoutesRouteNamePutRequest {
	return ApiRoutesRouteNamePutRequest{
		ApiService: a,
		ctx:        ctx,
		routeName:  routeName,
	}
}

// Execute executes the request
//
//	@return Route
func (a *DefaultAPIService) RoutesRouteNamePutExecute(r ApiRoutesRouteNamePutRequest) (*Route, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Route
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RoutesRouteNamePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routes/{routeName}"
	localVarPath = strings.Replace(localVarPath, "{"+"routeName"+"}", url.PathEscape(parameterValueToString(r.routeName, "routeName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateRouteRequest == nil {
		return localVarReturnValue, nil, reportError("updateRouteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateRouteRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicesGetRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
	wait       *string
	index      *string
}

// wait seconds
func (r ApiServicesGetRequest) Wait(wait string) ApiServicesGetRequest {
	r.wait = &wait
	return r
}

// index
func (r ApiServicesGetRequest) Index(index string) ApiServicesGetRequest {
	r.index = &index
	return r
}

func (r ApiServicesGetRequest) Execute() ([]Service, *http.Response, error) {
	return r.ApiService.ServicesGetExecute(r)
}

/*
ServicesGet Get all services

Retrieve a list of all services

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiServicesGetRequest
*/
func (a *DefaultAPIService) ServicesGet(ctx context.Context) ApiServicesGetRequest {
	return ApiServicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Service
func (a *DefaultAPIService) ServicesGetExecute(r ApiServicesGetRequest) ([]Service, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.wait != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait", r.wait, "form", "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicesIdDeleteRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
	id         string
}

func (r ApiServicesIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesIdDeleteExecute(r)
}

/*
ServicesIdDelete Delete a service

Delete an existing service

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID of the service to delete
	@return ApiServicesIdDeleteRequest
*/
func (a *DefaultAPIService) ServicesIdDelete(ctx context.Context, id string) ApiServicesIdDeleteRequest {
	return ApiServicesIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesIdDeleteExecute(r ApiServicesIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesIdPatchRequest struct {
	ctx                 context.Context
	ApiService          DefaultAPI
	id                  string
	patchServiceRequest *PatchServiceRequest
}

func (r ApiServicesIdPatchRequest) PatchServiceRequest(patchServiceRequest PatchServiceRequest) ApiServicesIdPatchRequest {
	r.patchServiceRequest = &patchServiceRequest
	return r
}

func (r ApiServicesIdPatchRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.ServicesIdPatchExecute(r)
}

/*
ServicesIdPatch Update a service

Update an existing service

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID of the service to update
	@return ApiServicesIdPatchRequest
*/
func (a *DefaultAPIService) ServicesIdPatch(ctx context.Context, id string) ApiServicesIdPatchRequest {
	return ApiServicesIdPatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Service
func (a *DefaultAPIService) ServicesIdPatchExecute(r ApiServicesIdPatchRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchServiceRequest == nil {
		return localVarReturnValue, nil, reportError("patchServiceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchServiceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicesIdRenewalPutRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
	id         string
}

func (r ApiServicesIdRenewalPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesIdRenewalPutExecute(r)
}

/*
ServicesIdRenewalPut Renewal a service

Renewal a service

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID of the service to renewal
	@return ApiServicesIdRenewalPutRequest
*/
func (a *DefaultAPIService) ServicesIdRenewalPut(ctx context.Context, id string) ApiServicesIdRenewalPutRequest {
	return ApiServicesIdRenewalPutRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesIdRenewalPutExecute(r ApiServicesIdRenewalPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesIdRenewalPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/{id}/renewal"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesPostRequest struct {
	ctx                  context.Context
	ApiService           DefaultAPI
	createServiceRequest *CreateServiceRequest
}

func (r ApiServicesPostRequest) CreateServiceRequest(createServiceRequest CreateServiceRequest) ApiServicesPostRequest {
	r.createServiceRequest = &createServiceRequest
	return r
}

func (r ApiServicesPostRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.ServicesPostExecute(r)
}

/*
ServicesPost Create a new service

Create a new service

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiServicesPostRequest
*/
func (a *DefaultAPIService) ServicesPost(ctx context.Context) ApiServicesPostRequest {
	return ApiServicesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Service
func (a *DefaultAPIService) ServicesPostExecute(r ApiServicesPostRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createServiceRequest == nil {
		return localVarReturnValue, nil, reportError("createServiceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createServiceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicesServiceNameGetRequest struct {
	ctx         context.Context
	ApiService  DefaultAPI
	serviceName string
	wait        *string
	index       *string
}

// wait seconds
func (r ApiServicesServiceNameGetRequest) Wait(wait string) ApiServicesServiceNameGetRequest {
	r.wait = &wait
	return r
}

// index
func (r ApiServicesServiceNameGetRequest) Index(index string) ApiServicesServiceNameGetRequest {
	r.index = &index
	return r
}

func (r ApiServicesServiceNameGetRequest) Execute() ([]Service, *http.Response, error) {
	return r.ApiService.ServicesServiceNameGetExecute(r)
}

/*
ServicesServiceNameGet Get service by name

Retrieve services by serviceName

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serviceName Name of the service to retrieve
	@return ApiServicesServiceNameGetRequest
*/
func (a *DefaultAPIService) ServicesServiceNameGet(ctx context.Context, serviceName string) ApiServicesServiceNameGetRequest {
	return ApiServicesServiceNameGetRequest{
		ApiService:  a,
		ctx:         ctx,
		serviceName: serviceName,
	}
}

// Execute executes the request
//
//	@return []Service
func (a *DefaultAPIService) ServicesServiceNameGetExecute(r ApiServicesServiceNameGetRequest) ([]Service, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesServiceNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/{serviceName}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceName"+"}", url.PathEscape(parameterValueToString(r.serviceName, "serviceName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.wait != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait", r.wait, "form", "")
	}
	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
